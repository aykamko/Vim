# vim: set ft=zsh:
###############################################################################
# Prezto
###############################################################################
# redraw prompt on async prompt callback signal
function TRAPUSR1 {
  _async_prompt_pid=0
  _async_prompt=$(cat $HOME/._async_prompt)
  zle && zle .reset-prompt
}

# run compinit -S on trusted computers
export TRUSTED_COMPINIT="HAL 9000"

# don't load prezto outside of tmux to speed up load
[[ -n $TMUX ]] || [[ -f "$HOME/.no_tmux" ]] && \
  [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]] && source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"

for keymap in 'emacs' 'viins'; do
  bindkey -M "$keymap" "$key_info[Control]P" history-substring-search-up
  bindkey -M "$keymap" "$key_info[Control]N" history-substring-search-down
done

# make Escape in vicmd mode do nothing
unset BEEP
bindkey -M vicmd '\e' beep

# load shell bookmarks
if [[ -f $HOME/.shell_bookmarks ]]; then
  source $HOME/.shell_bookmarks
fi

###############################################################################
# Neovim Pane Switching
###############################################################################
# vim
if (( $+commands[nvim] )); then
  alias vim=nvim
  alias vi=nvim
else
  alias vi=vim
fi

# only defined in neovim libvterm
if [[ -n $NVIM_LISTEN_ADDRESS ]]; then

  _nvr_up()    { nvr -c 'TmuxNavigateUp' }
  _nvr_right() { nvr -c 'TmuxNavigateRight' }
  _nvr_down()  { nvr -c 'TmuxNavigateDown' }
  _nvr_left()  { nvr -c 'TmuxNavigateLeft' }
  zle -N nvr_up _nvr_up
  zle -N nvr_right _nvr_right
  zle -N nvr_down _nvr_down
  zle -N nvr_left _nvr_left
  bindkey '^K' nvr_up
  bindkey '^L' nvr_right
  bindkey '^J' nvr_down
  bindkey '^H' nvr_left

  sp () { nvr -o $@ }
  vsp () { nvr -O $@ }
  ds() { nvr -c "DirectionalSplit $@" }

  alias nvim=nvr
  alias vim=nvr
  alias vi=nvr
  export EDITOR=nvr

  command_not_found_handler() {
    if [[ "$@" =~ ^: ]]; then
      nvr -c ${@:1}
    else
      return 127
    fi
  }

  fe() { nvr --remote-send "<esc><esc>:GitFZF $PWD<cr>" }

elif [[ -n $TMUX ]]; then
  alias ':q'='tmux kill-pane'
fi

###############################################################################
# Aliases & Functions
###############################################################################
# basics
alias restart="exec $SHELL"
alias c=clear
clr() {
  clear
  [[ -n $TMUX ]] && tmux clear-history
}
stripansi() {
  [[ $UNAME == darwin ]] && \
    sed -E "s/"$'\E'"\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g" ||
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g"
}
word() {
  awk "{print \$$1}"
}

alias cm='command'

alias rrm='command rm'

alias unixtime='date +%s'

alias vimrc='vi ~/.vimrc'
alias vis='vi -u ~/.vim/vimrc_small'
alias vimrc_small='vis ~/.vim/vimrc_small'

vim-profile() {
  $DOTFILES/vim-profiler/vim-profiler.py ${@:1:$((${#@} - 1))} $(which nvim) ${@: -1}
}

swpclean() {
  find . -name '*.sw*' -exec /bin/rm -rf {} \;
}

vimreplace() {
  [[ $# < 2 ]] && echo 'Not enough arguments' && return

  local search
  (( $+commands[ag] )) && \
    search="ag -l --nocolor $1" || \
    search="grep -rl $1 *"

  local -a matches
  while read line; do
    matches+=$line
  done < <(eval $search)

  # eventignore magic from http://stackoverflow.com/a/12487439
  vim -c "bufdo set eventignore-=Syntax | %s/$1/$2/gec | update" ${matches}
}

# Facebook Path Picker
alias pp=fpp

# zsh
alias zshso='source ~/.zshrc'
alias zshenv='vi ~/.zshenv'
alias zshrc='vi ~/.zshrc'
alias zprofile='vi ~/.zprofile'
alias zpreztorc='vi ~/.zpreztorc'
alias zlogin='vi ~/.zlogin'
alias zlocal='vi ~/.zshrc.local'

# git
alias gitconfig='vi ~/.gitconfig'
alias gitignore_global='vi ~/.gitignore_global'

# tmux
alias t='tmux'
alias tl='tmux ls'
alias detach='tmux detach'
alias tmuxconf="vi ~/.tmux.conf"
alias tconf='tmuxconf'
alias tname='tmux rename-session'
tswap() {
  tmux swap-window -t $1
}
notmux() {
  touch ~/.no_tmux
}
if [[ -z $TMUX ]]; then
  tmux() { [[ -z "$@" ]] && command tmux new -A -s main || command tmux "$@" }
fi

tkill() {
  case $1 in
    (-1)
      command tmux kill-session;;
    (-a|--all)
      command tmux kill-session -a;;
    (*)
      command tmux kill-session -a
      command tmux kill-session;;
  esac
}

# CSV
# source: https://chrisjean.com/view-csv-data-from-the-command-line/

csvless() {
  local outputcmd
  if [[ -n $2 ]]; then
    outputcmd="head -n $2"
  else
    outputcmd="cat"
  fi
  eval "$outputcmd $1" | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S
}

# julia
alias jl=julia

# python
alias ipy3=ipython
alias ipy=ipython2
alias py=python
alias py3=python3
venv() {
  source $1/bin/activate
}
rpdb() {
  socat readline tcp:${2:-0.0.0.0}:${1:-4444}
}

ctags() {
  unset -f ctags && \
    brew list ctags >/dev/null 2>&1 && \
    alias ctags="$(brew --prefix)/bin/ctags"
  ctags "$@"
}
# re-activate any active VIRTUAL_ENV on shell start up
if [[ -n $VIRTUAL_ENV ]]; then
  source ${VIRTUAL_ENV}/bin/activate
fi

# if (( $+commands[pylama] )); then
#   pylama() { # pylama should use pylama.ini at root of git repo
#     local gitroot=$(git rev-parse --show-toplevel 2>/dev/null)
#     [[ $? -ne 0 || $* == *"-o"* || $* == *"--options"* ]] && \
#       pylama $* || \
#       pylama --options "${gitroot}/pylama.ini" "$@"
#   }
# fi

# modified from http://unix.stackexchange.com/questions/13464
upsearch() {
  local curdir="$PWD"
  while 1; do
    [[ -f "$curdir/$1" ]] && echo "$curdir/$1" && return
    [[ $curdir == "/" ]] && return
    curdir=$(dirname "$curdir")
  done
}
dmake() { # django
  local django=$(upsearch manage.py)
  [[ -n $django ]] && \
    (cd $(dirname $django) && python $django "$@") || \
    echo "Couldn't find manage.py"
}

# ruby
if (( $+commands[rbenv] )); then
  rbenv() { unset -f rbenv && eval "$(rbenv init - | tail -n +2)" && rbenv "$@"; }
fi

if (( $+commands[nodenv] )); then
  nodenv() { unset -f nodenv && eval "$(nodenv init - | tail -n +2)" && nodenv "$@"; }
fi

# if (( $+commands[pyenv] )); then
#   pyenv() { unset -f pyenv && eval "$(pyenv init - | tail -n +2)" && pyenv "$@"; }
# fi

# git
# (( $+commands[hub] )) && alias git=hub TODO: fix hub branch completion
alias g='git'

# context from root of git directory
gr() {
  local root=$(command git rev-parse --show-toplevel 2> /dev/null)
  [[ $? == 0 ]] && cd $root || cd "$@"
}
alias '$'=gr

if (( $+commands[tag] )); then
  tag() { command tag "$@"; source ${TAG_ALIAS_FILE:-/tmp/tag_aliases} 2>/dev/null }
  alias ag=tag
fi

# other
alias temp="cd $HOME/temp"
alias texclean='rm -rf *.aux *.fdb_latexmk *.fls *.log *.synctex.gz 2>/dev/null'

# NOTE: overrides unix `last` command, but that's not too useful anyway
last() {
  [[ -z $TMUX && -z $NVIM_LISTEN_ADDRESS ]] && echo 'Sorry, not in tmux or nvim. :(' && return

  local prev_cmd
  prev_cmd=$(fc -ln -1 | sed -e 's/[\/&]/\\&/g')

  local last_out=$TMPDIR/last.$$
  if [[ -n $NVIM_LISTEN_ADDRESS ]]; then
    nvr -c "w! $last_out" >/dev/null
  else
    tmux capture-pane -pe -S - >! $last_out
  fi

  tail -r $last_out | awk "/$PROMPT_DELIM/{p=!p;if(p){next}else{exit}} p" | tail -r
}
if (( $+commands[fpp] )); then
  alias lp='last | fpp'
fi

alias vssh='vagrant up && vagrant ssh'

psag() {
  ps aux | ag "[${1[1]}]${1[2,-1]}"
}

pskill() {
  ps aux | ag "[${1[1]}]${1[2,-1]}" | awk '{print $2}' | sudo xargs -I% command kill ${2:-} %
}

###############################################################################
# Builtin overrides
###############################################################################
[[ $UNAME == darwin ]] && \
  alias fancyls="ls -G" || \
  alias fancyls="ls --group-directories-first --color=auto"

# override cd to do ls and vi when necessary
_better_cd() {
  set -- ${1//,/.} # replace commas (,) with periods (.) [looking at u Golang]
  if [[ -f $1 ]]; then
    local fdir=$(dirname $1)
    [[ -d $fdir ]] && builtin cd $fdir && fancyls && vim $(basename $1) ${*:2}
  else
    builtin cd "$@" && fancyls
  fi
}
alias cd=_better_cd

# tab completion in dotfiles directory
dotfiles() { cd $DOTFILES/$1; }
compctl -f -W $DOTFILES/ dotfiles

# override cat
_cat_ls() { [[ -d $1 ]] && fancyls $1 || command cat "$@"; }
alias cat=_cat_ls

###############################################################################
# Special Settings
###############################################################################
[[ -f "$HOME/.zshrc.os" ]] && source "$HOME/.zshrc.os"         # OS Specific
[[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"   # Local
[[ -f "$HOME/.secret_zshrc" ]] && source "$HOME/.secret_zshrc" # Secret!

###############################################################################
# z
###############################################################################
[[ -f $DOTFILES/z/z.sh ]] && source $DOTFILES/z/z.sh

###############################################################################
# vim fzf
###############################################################################
if [[ -f ~/.fzf.zsh ]]; then
  source ~/.fzf.zsh
  export FZF_COMPLETION_TRIGGER='jk'
  export FZF_DEFAULT_COMMAND='command ag --nocolor --hidden --ignore-dir=.git -g "" $(git rev-parse --show-toplevel 2>/dev/null)'
  export FZF_CTRL_T_COMMAND='command ag --nocolor --hidden --ignore-dir=.git -g ""'
  export FZF_DEFAULT_OPTS='--ansi -x -m --bind=alt-k:up,alt-j:down'
  bindkey '^F' fzf-file-widget
fi

###############################################################################
# direnv
###############################################################################
if (( $+commands[direnv] )); then
  eval "$(direnv hook zsh)"
fi

###############################################################################
# zsh scripts
###############################################################################
if [[ -d $DOTFILES/zsh/scripts ]]; then
  for f in $DOTFILES/zsh/scripts/*; do
    source $f
  done
fi

unsetopt CORRECT         # disable autocorrect suggestions for commands
unsetopt AUTO_NAME_DIRS  # don't resolve environment variables in prompt
setopt NO_NOMATCH        # pass bad match to command

# disable ctrl-d to logout
setopt IGNORE_EOF
bindkey -r '^D'

# don't warn when overwriting existing file
setopt clobber

if [[ -o INTERACTIVE && ! -o LOGIN ]]; then
  _startup_time_prompt '\x1b[35m'  # purple
fi
