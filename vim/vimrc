""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{ vim-plug
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('vim_starting')
  set encoding=utf-8 " necessary to show Unicode glyphs
endif
set nocompatible   " be iMproved
let s:darwin = has('mac')
let s:tmux = $TMUX != ''

" vimrc folding
autocmd VimEnter .vimrc
      \  set foldmethod=marker
      \| set foldlevel=0

" autoinstall vim-plug
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall | PlugUpdate
endif

let g:plug_dir = '~/.vim/bundle/'
call plug#begin(g:plug_dir)

Plug 'ConradIrwin/vim-bracketed-paste'
Plug 'SirVer/ultisnips'
Plug 'airblade/vim-gitgutter'
Plug 'aykamko/gitsync.nvim'
Plug 'aykamko/vim-textobj-user'
Plug 'aykamko/neomake'
Plug 'christoomey/vim-tmux-navigator'
Plug 'haya14busa/incsearch.vim'
Plug 'itchyny/lightline.vim'
Plug 'junegunn/vim-easy-align'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'rking/ag.vim'
Plug 'takac/vim-hardtime'
Plug 'tmux-plugins/vim-tmux-focus-events'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'
Plug 'unblevable/quick-scope'
Plug 'wellle/targets.vim'

Plug 'easymotion/vim-easymotion'
      \ | Plug 'aykamko/vim-easyoperator-line'
      \ | Plug 'aykamko/vim-easymotion-segments'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
Plug 'mattn/webapi-vim'
      \ | Plug 'mattn/gist-vim', { 'on': 'Gist' }
Plug 'junegunn/goyo.vim',       { 'on': 'Goyo' }

Plug 'Glench/Vim-Jinja2-Syntax',     { 'for': 'jinja' }
Plug 'a.vim',                        { 'for': ['c', 'cpp'] }
Plug 'fatih/vim-go',                 { 'for': 'go' }
Plug 'fsharp/vim-fsharp',            { 'for': 'fsharp', 'do': 'make fsautocomplete' }
Plug 'hynek/vim-python-pep8-indent', { 'for': 'python' }
Plug 'jason0x43/vim-js-indent',      { 'for': 'javascript' }
Plug 'kchmck/vim-coffee-script',     { 'for': 'coffee' }
Plug 'leafgarland/typescript-vim',   { 'for': 'typescript' }
Plug 'lervag/vimtex',                { 'for': 'tex' }
Plug 'mattn/emmet-vim',              { 'for': ['jinja', 'html'] }
Plug 'nono/vim-handlebars',          { 'for': ['jinja', 'html'] }
Plug 'slim-template/vim-slim',       { 'for': 'slim' }
Plug 'tpope/vim-rails',              { 'for': 'ruby' }
Plug 'vim-scripts/sh.vim--Cla',      { 'for': ['sh', 'zsh', 'bash'] }

" currently testing async loading of YCM using neovim
Plug 'Valloric/YouCompleteMe', { 'do': './install.py --clang-completer --gocode-completer' } |
      \ Plug 'rdnetto/YCM-Generator',  { 'branch': 'stable', 'for': ['c', 'cpp', 'make'] }

call plug#end()
filetype plugin indent on " required

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" General Settings {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let mapleader = ' '
let maplocalleader = ' '

let s:E = '✖'
let s:W = '⚠'

" Don't use virtualenv python
if !empty(glob('/usr/local/bin/python'))
  let g:python_host_prog='/usr/local/bin/python'
  let g:python3_host_prog='/usr/local/bin/python3'
else
  let g:python_host_prog='/usr/bin/python'
  let g:python3_host_prog='/usr/bin/python3'
end

" Display
set ruler           " show cursor position
set nonumber        " hide line numbers
set nolist          " hide tabs and EOL chars
set showcmd         " show normal mode commands as they are entered
set noshowmode      " don't show mode becase powerline already does it
set nowrap          " don't wrap long lines

" Scrolling
set scrolloff=5     " minimum of three lines above and below cursor
set scrolljump=5    " scroll five lines at a time vertically
set sidescroll=10   " minumum columns to scroll horizontally

" Search
set nohlsearch        " persist search highlighting, initially
set incsearch       " search with typeahead

" Indent
set autoindent      " carry indent over to new lines

" Clipboard
set clipboard=unnamed " set unnamed to copy to system clipboard

" Mouse
set mouse=a           " enable mouse movement

" Backups
set backupdir=/tmp//,.
set directory=/tmp//,.
if v:version >= 703
  set undodir=/tmp//,.
endif

" Other
set noerrorbells      " no bells in terminal

set tags=tags;/       " search up the directory tree for tags

set undolevels=1000   " number of undos stored
set viminfo='50,"50   " '=marks for x files, "=registers for x files

" netrw
let g:netrw_liststyle=3
let g:netrw_winsize=20
nnoremap <silent> <leader>k :Lexplore<CR>

" hack to always display sign column
augroup DisplaySignCol
  au!
  au BufEnter * sign define dummy
  au BufEnter * exe 'sign place 9999 line=1 name=dummy buffer='.bufnr('')
augroup END

" remove small delay when leaving insert mode
if !has('gui_running')
  set ttimeoutlen=10
  augroup fast_escape
    autocmd!
    autocmd InsertEnter * set timeoutlen=0
    autocmd InsertLeave * set timeoutlen=1000
  augroup END
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Colorscheme {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax enable

let g:hybrid_use_iTerm_colors = 1
colorscheme hybrid-ayk
set t_Co=256            " tell vim that terminal supports 256 colors

" highlight columns 79, 80, 119, 120
highlight ColorColumn ctermbg=234
set colorcolumn=79,80,99,100,119,120

" change vim split line color to differentiate from tmux
highlight StatusLineNC ctermfg=5
highlight VertSplit ctermfg=5

" unhighlight search terms
highlight Search ctermbg=236

" unhighlight sign column
highlight SignColumn cterm=NONE ctermbg=NONE

" add some extra keywords to Todo highlight group
fu! ExtraTodoHi()
  syn keyword extraTodo HACK INFO BUG NOTE containedin=.*Comment.*
  hi def link extraTodo Todo
endfu
augroup extraTodoHi
  autocmd!
  autocmd VimEnter * call ExtraTodoHi() | autocmd! extraTodoHi
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Line Numbering {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" toggle number/relativenumber on insert/normal mode
set number
autocmd! InsertEnter,InsertLeave,FocusLost,FocusGained *
      \ if !get(b:, 'goyo_enabled', 0) | set invrelativenumber | endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Indentation {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set shiftwidth=4
set tabstop=4
set softtabstop=4
set expandtab
set backspace=indent,eol,start
set textwidth=99

" vim-indent-guides
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_auto_colors = 0
let g:indent_guides_start_level = 2
hi IndentGuidesOdd ctermbg=NONE
hi IndentGuidesEven ctermbg=234

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Commands/Mappings {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" remap j/k for wrapped lines; add relative jumps to jumplist
" Source: reddit.com/r/vim/comments/3npf1z/using_jk_for_wrapped_lines_and_adding_jk_with_a/cvq2k3x
function! LineMotion(dir)
    execute "normal! " . (v:count1 > 1 ? "m'" . v:count1 : "g") . a:dir
endfunction
nnoremap <silent> j :<c-u>call LineMotion("j")<cr>
nnoremap <silent> k :<c-u>call LineMotion("k")<cr>

" because I suck
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev X x
cnoreabbrev WQ wq
cnoreabbrev Wq wq
cnoreabbrev wQ wq

" center screen horizontally
fu! HorizontalScroll(cols)
  if a:cols > 0
    exec "normal ".a:cols."zl"
  elseif a:cols < 0
    exec "normal ".-a:cols."zh"
  endif
endfu
nnoremap <silent> z\| :call HorizontalScroll(wincol() - (winwidth(0)/2))<CR>

" save to <leader>;
noremap <silent> <leader><leader> :up<CR>
vnoremap <silent> <leader><leader> :<C-U>p<CR>gv

" save+quit to <leader>
noremap <silent> <leader>x :update \| q<CR>
vnoremap <silent> <leader>x :<C-U>update \| q<CR>

" quit/force-quit to <leader>q/Q
noremap <silent> <leader>q :q<CR>
vnoremap <silent> <leader>q :<C-U>q<CR>
noremap <silent> <leader>Q :q!<CR>
vnoremap <silent> <leader>Q :<C-U>q!<CR>

" bind arrows to pageup/pagedown, since I don't use them otherwise
function! ScrollHalfScreen(down, visualmode)
  if !empty(a:visualmode) | exec "normal! gv" | endif
  let motion = a:down ? 'j' : 'k'
  exec 'normal! '.winheight('$')/2.motion
endfunction
nnoremap <silent> <Down> :<C-U>call ScrollHalfScreen(1, 0)<CR>
nnoremap <silent> <Up> :<C-U>call ScrollHalfScreen(0, 0)<CR>
vnoremap <silent> <Down> :<C-U>call ScrollHalfScreen(1, 1)<CR>
vnoremap <silent> <Up> :<C-U>call ScrollHalfScreen(0, 1)<CR>

" blackhole paste
function! BlackHolePaste(type)
  echo "hello"
  if a:type ==# 'char'
    silent exec 'normal! `[v`]"bdp'
  elseif a:type == 'v'
    silent exec 'normal! `<v`>"bdp'
  endif
endfunction
nnoremap <silent> <leader>p :set operatorfunc=BlackHolePaste<CR>g@
vnoremap <silent> <leader>p :<c-u>call BlackHolePaste(visualmode())<CR>
nnoremap <silent> dp "bddP

" vimrc and help
command! Vvimrc vsp $MYVIMRC
cnoreabbrev vimrc Vvimrc
command! Hvimrc sp $MYVIMRC
cnoreabbrev hvimrc Hvimrc
command! Vimso source $MYVIMRC
cnoreabbrev vimso Vimso
command! -nargs=* -complete=help Vhelp vertical help <args>
cnoreabbrev vhelp Vhelp

" copy to xclip with Control-C
nnoremap <C-y> :w !xsel<CR><CR>
vnoremap <C-y> "*y

" remap indent to use single >/<
noremap > >>
noremap < <<

" reselects visual box after shift
vnoremap < <gv
vnoremap > >gv

" repeat macro in register q
nnoremap Q @q

" toggle fold more easily
nnoremap z<Space> za

" paste in insert mode
" (depends on clipboard setting)
set pastetoggle=<F2>
inoremap <silent> <C-P> <F2><C-R>+<F2>

" get highlight group under cursor
" http://vim.wikia.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
nnoremap <silent> <C-s> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
      \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
      \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" prettify JSON
command! Prettify %!python -m json.tool

" search/replace visual selection
fu! ReplaceSelection(hasrange)
  if a:hasrange > 0
    call feedkeys(':%s/'.GetVisualSelection().'/', 'm')
  endif
endfu
command! -range=0 ReplaceSelection call ReplaceSelection(<count>)
vnoremap <leader>r :ReplaceSelection<CR>

" kill any trailing whitespace on save (Credit to Facebook)
let g:strip_whitespace_blacklist = ['snippets']
function! s:strip_whitespace()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfunction
augroup kill_whitespace
  autocmd!
  autocmd BufWritePre <buffer> if index(g:strip_whitespace_blacklist, &ft) < 0 |
        \ call s:strip_whitespace() | endif
augroup END

" set buffer to unmodifiable if read-only
function! s:set_unmodifiable()
  if &readonly && &modifiable
      setlocal nomodifiable
  endif
endfu
augroup set_unmodifiable
  autocmd!
  autocmd BufReadPost * call s:set_unmodifiable()
augroup END

" vim-tmux aware killpane
function! TmuxAwareKillpane()
  if s:tmux || winnr('$') > 1
    silent :q
  else
    call system('tmux kill-pane')
  endif
endfunction
nmap <silent> <C-x> :call TmuxAwareKillpane()<CR>
" TODO: look this up
" run this command in shell if vim-tmux-navigator isn't working in nvim
" $ infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti
" $ tic $TERM.ti

" tmux pane title
autocmd BufReadPost,FileReadPost,BufNewFile * let &titlestring=expand("%:t")
set title

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" quick-scope {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Source: https://gist.github.com/cszentkiralyi/dc61ee28ab81d23a67aa
" Only enable the quick-scope plugin's highlighting when using the f/F/t/T movements
let g:qs_enable = 0
let g:qs_enable_char_list = [ 'f', 'F', 't', 'T' ]
let g:qs_first_occurrence_highlight_color = 39
let g:qs_second_occurrence_highlight_color = 28

function! Quick_scope_selective(movement)
    let needs_disabling = 0
    if !g:qs_enable
        QuickScopeToggle
        redraw
        let needs_disabling = 1
    endif
    let letter = nr2char(getchar())
    if needs_disabling
       QuickScopeToggle
    endif
    return a:movement . letter
endfunction

for i in g:qs_enable_char_list
  execute 'noremap <expr> <silent>' . i . " Quick_scope_selective('". i . "')"
endfor

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" tComment {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Use <leader>c to comment lines of code
map <leader>c :TComment<CR>
vmap <leader>c :TComment<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Lightline {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set laststatus=2   " Always show the statusline
let g:lightline = {
      \   'colorscheme': 'Tomorrow_Night',
      \   'active': {
      \     'left': [['mode', 'paste'], ['fileinfo', 'syntax_err', 'syntax_war']],
      \     'right': [['lineinfo'], ['fugitive'], ['gitsync', 'filetype']]
      \   },
      \   'inactive': {
      \     'left': [['fileinfo']],
      \     'right': [['lineinfo'], ['fugitive'], ['gitsync', 'filetype']]
      \   },
      \   'component': {
      \     'fugitive': '%{exists("*fugitive#head")?fugitive#head(5):""}',
      \   },
      \   'component_function' : {
      \     'mode': 'LLMode',
      \     'fileinfo': 'LLFileInfo',
      \     'lineinfo': 'LLLineInfo',
      \   },
      \   'component_expand' : {
      \     'gitsync': 'Gitsync',
      \     'syntax_err': 'SyntaxError',
      \     'syntax_war': 'SyntaxWarning',
      \   },
      \   'component_type': {
      \     'gitsync': 'error',
      \     'syntax_err': 'error',
      \     'syntax_war': 'warning',
      \   },
      \ }

function! Gitsync()
  if !get(g:, 'gitsync_initialized', 0) | return '' | endif
  return GitsyncStatus(bufnr('%'))
endfunction

function! SyntaxError()
  if !exists('*neomake#statusline#LoclistCounts') | return '' | endif
  let counts = neomake#statusline#LoclistCounts()
  if !has_key(counts, 'E') | return '' | endif
  return printf('%s %d', s:E, counts['E'])
endfunction
function! SyntaxWarning()
  if !exists('*neomake#statusline#LoclistCounts') | return '' | endif
  let counts = neomake#statusline#LoclistCounts()
  if !has_key(counts, 'W') | return '' | endif
  return printf('%s %d', s:W, counts['W'])
endfunction

" mode
function! LLMode()
  return  &ft =~ 'netrw' ? 'netrw' :
        \ &ft =~ 'fzf' ? 'FZF' :
        \ lightline#mode()
endfunction

" filename and fileinfo
let g:pathname_depth = 3
function! LLModified()
  return index(['help', 'netrw'], &ft) > -1 ? '' :
        \ &modified ? '+' : ''
endfunction
function! LLReadonly()
  return index(['help', 'netrw'], &ft) < 0 && &readonly ? '🔒' : ''
endfunction
function! LLTrucatedFilePath()
  if &ft =~ 'netrw' | return '' | endif
  let fullpath = expand('%:p:~')
  return empty(fullpath) ? '[No Name]' :
        \ matchstr(fullpath,
        \   printf('\(\~\)\?\(/[0-9a-zA-Z_~\-. ]\+\)\{,%d}/[0-9a-zA-Z_\-. ]\+$',
        \   get(g:, 'pathname_depth', 3)))
endfunction
function! LLFileInfo()
  if index(['netrw', 'fzf'], &ft) > -1 | return '' | endif
  let segments = [LLReadonly(), LLTrucatedFilePath(), LLModified()]
  return substitute(join(segments, ' '), '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction
function! LLLineInfo()
  if index(['netrw', 'fzf'], &ft) > -1 | return '' | endif
  let [_, l, c, _] = getpos('.')
  return l.':'.c
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-easyalign {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <lEnter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. <leader>aip)
nmap <leader>a <Plug>(EasyAlign)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" a.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" toggle between .h and .c with <leader>a
nnoremap <leader>a :A<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" YouCompleteMe {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:ycm_confirm_extra_conf = 0
let g:ycm_global_ycm_extra_conf = $HOME.'/.vim/ycm_extra_conf.py'

" lazy load/exec ycm commands
function! YcmLazy(...)
  if !exists("*youcompleteme#Enable")
    echo "Loading YCM..."
    call plug#load('YouCompleteMe')
  endif
  if !exists(":YcmCompleter")
    call youcompleteme#Enable()
  endif
  exe printf(':YcmCompleter %s', join(a:000, ' '))
endfunction
command! -nargs=* YcmLazy call YcmLazy(<f-args>)

nnoremap <silent> <leader>yd :YcmForceCompileAndDiagnostics<cr>
nnoremap <silent> <leader>yo :YcmLazy GoTo<cr>

" semantic trigger for tex (suggested by :help vimtex)
if !exists('g:ycm_semantic_triggers')
  let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
      \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*, ?)*'
      \ ]

" Ultisnips doesn't seem to work without this
let g:UltiSnipsUsePythonVersion = 2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Neomake {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:neomake_verbose = 0 " useful for debug

hi NeomakeError ctermfg=red
hi NeomakeWarning ctermfg=yellow
let g:neomake_error_sign = {
      \ 'text': s:E,
      \ 'texthl': 'NeomakeError',
      \ }
let g:neomake_warning_sign = {
      \ 'text': s:W,
      \ 'texthl': 'NeomakeWarning',
      \ }

let g:neomake_statusline_callback = 'lightline#update'
if executable('pylama')
  let g:neomake_python_enabled_makers = ['pylama']
endif

function! ToggleLocationList()
  if empty(filter(tabpagebuflist(), 'getbufvar(v:val, "&buftype") is# "quickfix"'))
    lwindow
  else
    lclose
  endif
endfunction
nnoremap <silent> <leader>1 :call ToggleLocationList()<CR>

autocmd! BufWritePost * if !get(b:, 'goyo_enabled', 0) | Neomake | endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" fzf {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <silent> <leader>o :FZF<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" ag.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:ag_working_path_mode='r'

" source: http://stackoverflow.com/a/6271254
function! GetVisualSelection()
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunction

" redefine Ag to accept visual selections
function! AgSelection(bang, args, hasrange)
  if a:hasrange > 0
    let selection = GetVisualSelection()
    call ag#Ag(a:bang, a:args == '' ? selection : a:args.' '.selection) | return
  endif
  call ag#Ag(a:bang, a:args)
endfunction

augroup redefine_ag
  autocmd!
  autocmd! BufEnter *
        \  exec "command! -bang -nargs=* -range=0 -complete=file Ag call AgSelection('grep<bang>', <q-args>, <count>)"
        \| autocmd! redefine_ag
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-easymotion {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" enable easymotion with one leaderkey press
map <leader> <Plug>(easymotion-prefix)

" blue and green ayyy lmao
hi EasyMotionTarget ctermfg=39
hi EasyMotionTarget2First ctermfg=40
hi EasyMotionTarget2Second ctermfg=28

" vim-easyoperator-line
let s:EasyOperator_line_do_mapping = 0
let s:EasyOperator_line_first = 'CursorLine'
omap <silent>  <leader>l <Plug>(easyoperator-line-select)
xmap <silent>  <leader>l <Plug>(easyoperator-line-select)
nmap <silent> d<leader>l <Plug>(easyoperator-line-delete)
nmap <silent> y<leader>l <Plug>(easyoperator-line-yank)

" vim-easymotion-segments
let g:EasyMotionSegments_key = 's'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Text Objects {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-textobj-user.vim
augroup TextobjUserSetup
  autocmd!
  autocmd BufEnter * call TextobjUserSetup()
augroup END

function! TextobjUserSetup()
  if get(g:, 'textobj_user_loaded', 0)
    " textobj for current line
    " Copied from: https://github.com/kana/vim-textobj-user
    call textobj#user#plugin('line', {
          \   '-': {
          \     'select-a': 'al', 'select-a-function': 'TextobjCurrentLineA',
          \     'select-i': 'il', 'select-i-function': 'TextobjCurrentLineI',
          \   },
          \ })

    function! TextobjCurrentLineA()
      normal! 0
      let head_pos = getpos('.')
      normal! $
      let tail_pos = getpos('.')
      return ['v', head_pos, tail_pos]
    endfunction

    function! TextobjCurrentLineI()
      normal! ^
      let head_pos = getpos('.')
      normal! g_
      let tail_pos = getpos('.')
      let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
      return
      \ non_blank_char_exists_p
      \ ? ['v', head_pos, tail_pos]
      \ : 0
    endfunction

    " textobj to turn foo_bar_baz into foo_baz *and* quuxSpamEggs into quuxEggs
    " Copied from: https://github.com/Julian/vim-textobj-variable-segment/blob/master/plugin/textobj/variable-segment.vim
    call textobj#user#plugin('variable', {
        \ '-': {
        \     'select-a': 'as',  'select-a-function': 'TextobjSelectSegmentA',
        \     'select-i': 'is',  'select-i-function': 'TextobjSelectSegmentI',
        \ }})

    function! TextobjSelectSegment(object_type, right_boundary)
        let left_boundaries = ['_\+\i', '\<', '\l\u', '\u\u\ze\l', '\a\d', '\d\a', '#\a']
        call search(join(left_boundaries, '\|'), 'bce')
        let start_position = getpos('.')

        call search('\>', 'c')
        let word_end = getpos('.')
        call setpos('.', start_position)

        call search(a:right_boundary, 'c')
        for _ in range(v:count1 - 1)
            if getpos('.') != word_end
                call search(a:right_boundary)
            endif
        endfor
        let end_position = getpos('.')

        return ['v', start_position, end_position]
    endfunction

    function! TextobjSelectSegmentA()
        let right_boundaries = ['_', '\l\u', '\u\u\l', '\a\d', '\d\a', '\i\>', '\a#']
        let right_boundary = join(right_boundaries, '\|')
        let [type, start_position, end_position] = TextobjSelectSegment('a', right_boundary)
        let [_, start_line, start_column, _] = start_position

        call search('\i\>', 'c')
        if end_position == getpos('.') &&
         \ getline(start_line)[start_column - 2] =~# '_'
            let start_position[2] -= 1
        endif

        let was_small_camel = match(expand('<cword>'), '^_*\l.*\u') != -1
        if was_small_camel
            call search('\<', 'bc')
            let [_, _, word_start, _] = getpos('.')

            if start_column - 2 <= word_start ||
             \ getline(start_line)[:start_column - 2] =~# '^_*$'
                call setpos('.', end_position)
                normal! l~
            endif
        endif

        return [type, start_position, end_position]
    endfunction

    function! TextobjSelectSegmentI()
        let right_boundaries = ['\i_', '\l\u', '\u\u\l', '\a\d', '\d\a', '\i\>', '\a#']
        return TextobjSelectSegment('i', join(right_boundaries, '\|'))
    endfunction

    " select entire file
    " Source: https://github.com/kana/vim-textobj-entire
    call textobj#user#plugin('entire', {
    \      '-': {
    \        '*sfile*': expand('<sfile>:p'),
    \        'select-a': 'ae',  '*select-a-function*': 'TextobjSelectEntireA',
    \        'select-i': 'ie',  '*select-i-function*': 'TextobjSelectEntireI'
    \      }
    \    })

    function! TextobjSelectEntireA()
      " To easily back to the last position after a command.
      " For example: yae<C-o>
      mark '

      keepjumps normal! gg0
      let start_pos = getpos('.')

      keepjumps normal! G$
      let end_pos = getpos('.')

      return ['V', start_pos, end_pos]
    endfunction

    function! TextobjSelectEntireI()
      " To easily back to the last position after a command.
      " For example: yie<C-o>
      mark '

      keepjumps normal! gg0
      call search('^.', 'cW')
      let start_pos = getpos('.')

      keepjumps normal! G$
      call search('^.', 'bcW')
      normal! $
      let end_pos = getpos('.')

      return ['V', start_pos, end_pos]
    endfunction

  endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-hardtime {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:hardtime_default_on = 0
let g:hardtime_maxcount = 2
let g:hardtime_timeout = 5000

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" incsearch.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)

" stay on *
map <silent> g* :let @/='\<'.expand('<cword>').'\>'<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" UltiSnips {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:UltiSnipsEditSplit="horizontal"

" expand UltiSnips with Enter
let g:UltiSnipsExpandTrigger = "<nop>"
let g:ulti_expand_or_jump_res = 0
function! ExpandSnippetOrCarriageReturn()
    let snippet = UltiSnips#ExpandSnippetOrJump()
    if g:ulti_expand_or_jump_res > 0
        return snippet
    else
        return "\<CR>"
    endif
endfunction
inoremap <silent> <expr> <CR> pumvisible() ? "\<C-R>=ExpandSnippetOrCarriageReturn()\<CR>" : "\<CR>"

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Goyo {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! s:goyo_enter()
  set noshowmode
  set noshowcmd
  let b:goyo_enabled = 1
  let b:quitting = 0
  let b:quitting_bang = 0
  autocmd QuitPre <buffer> let b:quitting = 1
  cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
endfunction

function! s:goyo_leave()
  set showmode
  set showcmd
  let b:goyo_enabled = 0
  " Quit Vim if this is the only remaining buffer
  if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
    if b:quitting_bang
      qa!
    else
      qa
    endif
  endif
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Gitsync {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:gitsync_callback = 'lightline#update'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Filetype {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd BufNewFile,BufReadPost *.md set filetype=markdown
autocmd BufNewFile,BufReadPost *.hn set filetype=horn
autocmd BufNewFile,BufReadPost *.slim set filetype=slim
autocmd BufNewFile,BufReadPost Vagrantfile set filetype=ruby
autocmd FileType vim,javascript,html,jinja setl sw=2 sts=2 et
autocmd BufNewFile,BufReadPost COMMIT_EDITMSG
      \ set textwidth=72 |
      \ set colorcolumn=71,72 |
      \ call matchaddpos('ColorColumn', [[1, 49, 2]])

" line wrap sucks for some files, but it's nice to choose the wrap width
function! ManualFormat(type, ...)
  let og_width = &textwidth
  exec 'set textwidth='.get(b:, 'textwidth_manual', &textwidth)

  if a:0  " Invoked from Visual mode
    silent exe "normal! '<v'>gq"
  elseif a:type == 'line'
    silent exe "normal! '[V']gq"
  elseif a:type == 'block'
    silent exe "normal! '[\<C-V>']gq"
  else
    silent exe "normal! '[v']gq"
  endif

  exec 'set textwidth='.og_width
endfunction!

autocmd Filetype markdown,noft,text set wrap
autocmd Filetype tex,markdown,noft,text
      \ set breakindent |
      \ set linebreak |
      \ exec 'nnoremap <silent> $ g$' |
      \ exec 'nnoremap <silent> ^ g^' |
      \ let b:textwidth_manual = 119 |
      \ exec 'nnoremap <silent> gq :set opfunc=ManualFormat<CR>g@' |
      \ exec 'vnoremap <silent> gq :<C-U>call ManualFormat(visualmode(), 1)<CR>'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
