"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{ vim-plug
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('vim-starting')
  set encoding=utf-8 " necessary to show Unicode glyphs
end
if !has('nvim')
  set nocompatible   " be iMproved
end
let s:darwin = has('mac')
let s:tmux = $TMUX != ''

augroup vimrc_folding
  autocmd!
  autocmd BufNewFile,BufReadPost .vimrc
        \  set foldmethod=marker
        \| set foldlevel=0
        \| autocmd! vimrc_folding
augroup END

" autoinstall vim-plug
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif

let g:plug_dir = '~/.vim/bundle/'

call plug#begin(g:plug_dir)

Plug 'ConradIrwin/vim-bracketed-paste'
" Plug 'benekastah/neomake'
Plug 'ivalkeen/neomake', {'branch': 'place-all-signs'}
Plug 'christoomey/vim-tmux-navigator'
Plug 'drn/zoomwin-vim'
Plug 'haya14busa/incsearch.vim'
Plug 'itchyny/lightline.vim'
" Plug 'jeetsukumaran/vim-buffergator'
Plug 'junegunn/vim-easy-align'
Plug 'kana/vim-textobj-user'
Plug 'mhinz/vim-grepper'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'tmux-plugins/vim-tmux-focus-events'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'
Plug 'wellle/targets.vim'

Plug 'easymotion/vim-easymotion'
      \ | Plug 'aykamko/vim-easyoperator-line'
      \ | Plug 'aykamko/vim-easymotion-segments'
Plug 'mattn/webapi-vim'
      \ | Plug 'mattn/gist-vim', { 'on': 'Gist' }
Plug 'junegunn/goyo.vim',        { 'on': 'Goyo' }
Plug 'scrooloose/nerdtree',      { 'on': ['NERDTreeFind', 'NERDTreeToggle'] }


Plug 'Glench/Vim-Jinja2-Syntax',     { 'for': 'jinja' }
Plug 'a.vim',                        { 'for': ['c', 'cpp'] }
Plug 'fatih/vim-go',                 { 'for': 'go' }
Plug 'hynek/vim-python-pep8-indent', { 'for': 'python' }
Plug 'kchmck/vim-coffee-script',     { 'for': 'coffee' }
Plug 'leafgarland/typescript-vim',   { 'for': 'typescript' }
Plug 'lervag/vimtex',                { 'for': 'tex' }
Plug 'mattn/emmet-vim',              { 'for': ['jinja', 'html'] }
Plug 'nono/vim-handlebars',          { 'for': ['jinja', 'html'] }
Plug 'vim-scripts/sh.vim--Cla',      { 'for': ['sh', 'zsh', 'bash'] }
Plug 'jez/vim-github-hub',           { 'for': 'markdown.ghpull' }

augroup slim_filetype
  autocmd!
  autocmd BufNewFile,BufReadPost *.slim set filetype=slim
augroup END
Plug 'slim-template/vim-slim',       { 'for': 'slim' }

" augroup jsx_filetype
"   autocmd!
"   autocmd BufNewFile,BufReadPost *.jsx set filetype=javascript.jsx
" augroup END
Plug 'othree/yajs.vim', { 'for': 'javascript' }
Plug 'gavocanov/vim-js-indent', { 'for': 'javascript' }
Plug 'mxw/vim-jsx'

if has('nvim')
  Plug 'Shougo/deoplete.nvim'
  Plug 'euclio/vim-markdown-composer', { 'for': 'markdown' }
  Plug 'Shougo/neosnippet.vim'
endif

Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
Plug 'junegunn/fzf.vim'

function! s:gitroot(...)
  let from_dir = a:0 ? a:1 : '.'
  let gitroot = system('git -C '.from_dir.' rev-parse --show-toplevel')
  if !v:shell_error
    return substitute(gitroot, '\n\+$', '', 'g').'/'
  endif
endfunction
command! -nargs=? Groot echo s:gitroot(<f-args>)

let gitroot = s:gitroot()
if executable(gitroot.'bin/rails') || executable(gitroot.'script/rails')
  Plug 'tpope/vim-rails', { 'for': 'ruby' }
end

call plug#end()
filetype plugin indent on " required

function! s:plug_loaded(plug_name) abort
  return !empty(get(g:plugs, a:plug_name))
endfunction
command! -nargs=1 PlugLoaded echo s:plug_loaded(<f-args>)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" General Settings {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let mapleader = ' '
let maplocalleader = ' '

let s:E = '✖'
let s:W = '▲'

" skip checks
let g:python_host_skip_check = 1
let g:python3_host_skip_check = 1

" Display
set ruler           " show cursor position
set nonumber        " hide line numbers
set nolist          " hide tabs and EOL chars
set showcmd         " show normal mode commands as they are entered
set noshowmode      " don't show mode becase powerline already does it
set nowrap          " don't wrap long lines

" Scrolling
set scrolloff=5     " minimum of three lines above and below cursor
set scrolljump=5    " scroll five lines at a time vertically
set sidescroll=10   " minumum columns to scroll horizontally

" Search
set nohlsearch      " persist search highlighting, initially
set incsearch       " search with typeahead

" Indent
set autoindent      " carry indent over to new lines

" Clipboard
set clipboard=unnamed " set unnamed to copy to system clipboard

" Mouse
set mouse=a           " enable mouse movement

" Backups
set backupdir=/tmp//,.
set directory=/tmp//,.
if v:version >= 703
  set undodir=/tmp//,.
endif

" Other
set noerrorbells      " no bells in terminal

set tags=.git/tags,tags;/       " search up the directory tree for tags

set undolevels=1000   " number of undos stored
if has('nvim')
  set shada='100,<1000,s100,n$HOME/.nvim.shada
else
  set viminfo='50,"50   " '=marks for x files, "=registers for x files
endif

" hack to always display sign column
augroup display_sign_col
  autocmd!
  autocmd BufEnter * sign define dummy
  autocmd BufEnter * if &buftype !=# 'terminal' |
        \ exec 'sign place 9999 line=1 name=dummy buffer='.bufnr('') |
        \ endif
  if has('nvim')
    " no sign column in terminals pls
    autocmd TermOpen * exec 'sign unplace * buffer='.bufnr('')
    autocmd TermOpen * set bufhidden=delete
    autocmd TermClose * exec 'sign place 9999 line=1 name=dummy buffer='.bufnr('')
  endif
augroup END

" remove small delay when leaving insert mode
if !has('nvim') && !has('gui_running')
  set ttimeoutlen=10
  augroup fast_escape
    autocmd!
    autocmd InsertEnter * set timeoutlen=0
    autocmd InsertLeave * set timeoutlen=1000
  augroup END
endif

let g:loaded_matchparen = 1  " disable matchparen
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Colorscheme {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('nvim')
  set termguicolors
endif
syntax enable
set lazyredraw  " lifesaver

set background=dark
try
  colorscheme hybrid_ayk
catch /:E185:/
  " silently ignore if colorscheme not found
endtry

function! GetHiKey(group, key)
  redir => highlight_output
  exec "silent highlight ".a:group
  redir END
  for key_val in split(highlight_output)
    if key_val =~ '^'.a:key
      return key_val[(len(a:key) + 1):]
    endif
  endfor
endfunction
function! RGBtoHex(r, g, b)
  return join(['#', printf('%.2x', a:r), printf('%.2x', a:g), printf('%.2x', a:b)], '')
endfunction
function! Adjust(color, amount)
  let color = (a:color[0] == '#') ? a:color[1:] : a:color
  if type(a:amount) == 5  " float
    let amount = a:amount
  else
    let amount = (a:amount / 100.0)
  endif
  let adj = float2nr(255 * amount)
  let r = max([str2nr(color[0:1], 16) + adj, 0])
  let g = max([str2nr(color[2:3], 16) + adj, 0])
  let b = max([str2nr(color[4:5], 16) + adj, 0])
  return RGBtoHex(r, g, b)
endfunction
function! Darken(color, amount)
  return Adjust(a:color, -a:amount)
endfunction
function! Lighten(color, amount)
  return Adjust(a:color, a:amount)
endfunction

" adjust colorcolumn
exec 'highlight! ColorColumn ctermbg=235 guibg='.
      \ Darken(GetHiKey('Normal', 'guibg'), 0.015)

let g:colorcolumn_blacklist = ['qf']
augroup display_colorcolumn
  autocmd!
  autocmd Filetype *
        \ if index(g:colorcolumn_blacklist, &ft) < 0 |
        \ setlocal colorcolumn=79,80,99,100,119,120 |
        \ endif
augroup END

" adjust Search highlighting
exec 'highlight! Search guifg=NONE guibg='.
      \ Lighten(GetHiKey('Normal', 'guibg'), 10)

" change vim split line color to differentiate from tmux
exec 'highlight! StatusLineNC ctermfg=5 guifg='.g:terminal_color_5
exec 'highlight! VertSplit ctermfg=5 guifg='.g:terminal_color_5

" add some extra keywords to Todo highlight group
syn keyword extraTodo HACK INFO BUG NOTE containedin=.*Comment.*
hi! def link extraTodo Todo

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Line Numbering {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" toggle number/relativenumber on insert/normal mode
if &buftype !=# 'terminal' | set number | set relativenumber | endif
augroup line_numbering
  autocmd!
  " autocmd! InsertEnter,InsertLeave,FocusLost,FocusGained * TODO: fix these
  autocmd InsertEnter,InsertLeave *
        \ if !get(b:, 'goyo_enabled', 0) && &buftype !=# 'terminal' |
        \ set invrelativenumber | endif
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Indentation {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set shiftwidth=4
set tabstop=4
set softtabstop=4
set expandtab
set backspace=indent,eol,start
set textwidth=99
augroup modify_textwidth
  autocmd!
  autocmd FileType sh,bash,zsh set textwidth=79
augroup END

" vim-indent-guides
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_auto_colors = 0
let g:indent_guides_start_level = 2
hi! IndentGuidesOdd ctermbg=NONE guibg=NONE
exec 'hi! IndentGuidesEven ctermbg=234 guibg='.Darken(GetHiKey('Normal', 'guibg'), 0.015)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Commands/Mappings {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" remap j/k for wrapped lines; add relative jumps to jumplist
" Source: reddit.com/r/vim/comments/3npf1z/using_jk_for_wrapped_lines_and_adding_jk_with_a/cvq2k3x
function! s:linemotion(dir)
  return (v:count1 > 1 ? "m'".v:count1 : 'g').a:dir
endfunction
nnoremap <silent><expr> j <SID>linemotion('j')
nnoremap <silent><expr> k <SID>linemotion('k')
vnoremap <silent><expr> j <SID>linemotion('j')
vnoremap <silent><expr> k <SID>linemotion('k')

" makes sense
nnoremap <silent> Y yg_
nnoremap <silent> yY ^yg_
nnoremap <silent> dD ^D
nnoremap <silent> cC ^C

" because I suck
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev X x
cnoreabbrev WQ wq
cnoreabbrev Wq wq
cnoreabbrev wQ wq

" Easily move to start/end of line
nnoremap H 0
vnoremap H 0
nnoremap L $
vnoremap L $

" move screen by a:cols_dt columns
function! s:horizontal_scroll(cols_dt)
  if a:cols_dt > 0
    return a:cols_dt.'zl'
  elseif a:cols_dt < 0
    return -a:cols_dt.'zh'
  endif
endfunction
nnoremap <silent><expr> z\| <SID>horizontal_scroll(wincol() - (winwidth(0) / 2))

" save to <leader>;
noremap <silent> <leader><leader> :up<CR>
vnoremap <silent> <leader><leader> :<C-U>p<CR>gv

" save+quit to <leader>
noremap <silent> <leader>x :update \| q<CR>
vnoremap <silent> <leader>x :<C-U>update \| q<CR>

" quit/force-quit to <leader>q/Q
noremap <silent> <leader>q :q<CR>
vnoremap <silent> <leader>q :<C-U>q<CR>
noremap <silent> <leader>Q :q!<CR>
vnoremap <silent> <leader>Q :<C-U>q!<CR>

" bind arrows to pageup/pagedown, since I don't use them otherwise
function! s:scroll_half_screen(motion)
  return (winheight('$') / 2).a:motion
endfunction
nnoremap <silent><expr> <Down> <SID>scroll_half_screen('j')
nnoremap <silent><expr> <Up> <SID>scroll_half_screen('k')
vnoremap <silent><expr> <Down> <SID>scroll_half_screen('j')
vnoremap <silent><expr> <Up> <SID>scroll_half_screen('k')

function! s:blackhole_paste(mode)
  if a:mode ==# 'char'
    let start_mark='`['
    let end_mark='`]'
  elseif index(['v', 'V'], a:mode) >= 0
    let start_mark='`<'
    let end_mark='`>'
  endif
  silent exec 'normal! '.start_mark
  let start_col=col('.')
  silent exec 'normal! v'.end_mark.'"bd'
  let end_col=col('.')
  if end_col < start_col  " happens when at end of line
    silent exec 'normal! p'
  else
    silent exec 'normal! P'
  endif
endfunction
function! s:blackhole_delete(mode)
  if a:mode ==# 'char'
    silent exec 'normal! `[v`]"bd'
  elseif index(['v', 'V'], a:mode) >= 0
    silent exec 'normal! `<v`>"bd'
  endif
endfunction
nnoremap <silent> mp :set operatorfunc=<SID>blackhole_paste<CR>g@
vnoremap <silent> mp :<c-u>call <SID>blackhole_paste(visualmode())<CR>
nnoremap <silent> md :set operatorfunc=<SID>blackhole_delete<CR>g@
vnoremap <silent> md :<c-u>call <SID>blackhole_delete(visualmode())<CR>
nnoremap <silent> mm "bdd
nnoremap <silent> dp "bddP

" directional split for files or new buffers
function! OpenDirectionalSplit(...) abort
  let g:last_direction_split = 0

  let file = ''
  if len(a:000) > 0
    let file = a:000[0]
    if file == 'NONE'
      let file = ''
    endif
  endif

  if len(a:000) > 1
    let dirchoice = a:000[1]
  else
    echohl Question
    echom 'Choose split direction. [hjklt or Enter] '
    echohl Normal
    call inputsave()
    let char = getchar()
    call inputrestore()
    redraw!
    if char == 27 " Esc
      return
    elseif char == 13  " Enter
      let dirchoice = 'e'
    else
      let dirchoice = nr2char(char)
    end
  end

  if !empty(file)
    let dirmap = {
          \ 'e': 'drop',
          \ 'h': 'aboveleft vsp | drop',
          \ 'j': 'belowright sp | drop',
          \ 'k': 'aboveleft sp | drop',
          \ 'l': 'belowright vsp | drop',
          \ 't': 'tabnew | drop',
          \ }
  else
    let dirmap = {
          \ 'e': '',
          \ 'h': 'aboveleft vnew',
          \ 'j': 'belowright new',
          \ 'k': 'aboveleft new',
          \ 'l': 'belowright vnew',
          \ 't': 'tabnew',
          \ }
  endif

  let action = get(dirmap, dirchoice)
  if empty(action)
    echohl Error
    echom 'Unknown direction: '.dirchoice
    echohl Normal
  else
    let g:last_direction_split = dirchoice
    exec join([action, file])
  endif
endfunction
command! -bar -nargs=* DirectionalSplit call OpenDirectionalSplit(<f-args>)

" vimrc and help
command! -nargs=? Vimrc DirectionalSplit $MYVIMRC <args>
cnoreabbrev vimrc Vimrc
command! Vimso source $MYVIMRC
cnoreabbrev vimso Vimso
command! -nargs=* -complete=help Vhelp vertical help <args>
cnoreabbrev vhelp Vhelp

" copy to xclip with Control-C
nnoremap <C-y> :w !xsel<CR><CR>
vnoremap <C-y> "*y

" remap indent to use single >/<
noremap > >>
noremap < <<

" reselects visual box after shift
vnoremap < <gv
vnoremap > >gv

" repeat macro in register q
nnoremap Q @q

" toggle fold more easily
nnoremap z<Space> za

" switching tabs
for i in range(0, 9)
  exec 'nnoremap t'.i.' '.i.'gt'
endfor

" command-line history
" set cedit=<C-R>

" paste in insert mode
" (depends on clipboard setting)
set pastetoggle=<F2>
inoremap <silent> <C-P> <F2><C-R>+<F2>

" get highlight group under cursor
" http://vim.wikia.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
nnoremap <silent> <C-s> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
      \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
      \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" prettify JSON/XML
command! Prettify %!python -m json.tool

" source: http://stackoverflow.com/a/6271254
function! s:get_visual_selection()
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, '\n')
endfunction

" search/replace visual selection
function! s:replace_selection(hasrange)
  if a:hasrange > 0
    call feedkeys(':%s/'.s:get_visual_selection().'/', 'm')
  endif
endfunction
command! -range=0 ReplaceSelection call s:replace_selection(<count>)
vnoremap <leader>r :ReplaceSelection<CR>

" kill any trailing whitespace on save (Credit to Facebook)
let g:strip_whitespace_blacklist = ['snippets']
function! s:strip_whitespace()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfunction
function! s:should_strip_whitespace()
  return index(g:strip_whitespace_blacklist, &ft) < 0 &&
              \ get(g:, 'strip_whitespace_pls', 1) &&
              \ &buftype !=# 'terminal'
endfunction
command! -bar -nargs=0 StripWhitespace call s:strip_whitespace()
augroup kill_whitespace
  autocmd!
  autocmd BufWritePre *
        \ if s:should_strip_whitespace() |
        \ StripWhitespace |
        \ endif
augroup END

" set buffer to unmodifiable if read-only
function! s:set_unmodifiable()
  if &readonly && &modifiable
    setlocal nomodifiable
  endif
endfu
augroup set_unmodifiable
  autocmd!
  autocmd BufReadPost * call s:set_unmodifiable()
augroup END

" zoom into pane
if has('nvim')
  " removed 'key', 'oft', 'sn', 'tx', 'bt' options which do not work with nvim
  let g:zoomwin_localoptlist = [
        \ "ai","ar","bh","bin","bl","bomb","cfu","ci","cin","cink",
        \ "cino","cinw","cms","com","cpt","diff","efm","eol","ep","et",
        \ "fenc","fex","ff","flp","fo","ft","gp","imi","ims","inde","inex",
        \ "indk","inf","isk","kmp","lisp","mps","ml","ma","mod","nf","ofu",
        \ "pi","qe","ro","sw","si","sts","spc","spf","spl","sua","swf",
        \ "smc","syn","ts","tw","udf","wfh","wfw","wm"
        \ ]
endif

function! s:zoomwin_wrapper()
  let t:zoomed = !get(t:, 'zoomed', 0)
  ZoomWin
endfunction
nnoremap <silent> <leader>z :call <SID>zoomwin_wrapper()<CR>

" vim-tmux aware killpane
function! TmuxAwareKillpane()
  if s:tmux || winnr('$') > 1
    silent :q
  else
    call system('tmux kill-pane')
  endif
endfunction
nmap <silent> <C-x> :call TmuxAwareKillpane()<CR>
" HACK: run this command in shell if vim-tmux-navigator isn't working in nvim
" $ infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti
" $ tic $TERM.ti

" tmux pane title
function! s:xterm_title()
  let title=expand('%:t')
  return empty(title) ? '[No Name]' : title
endfunction
set title
augroup tmux_pane_title
  autocmd!
  autocmd BufReadPost,FileReadPost,BufNewFile,BufEnter *
        \ let &titlestring=s:xterm_title()
augroup END

" jump to tag
function! s:directional_tag(tag)
  let tselect_out = ''
  try
    redir => tselect_out
    silent exec 'tselect '.a:tag
    redir END
  catch /:E426/
    echohl Error
    echom "Tag '".a:tag."' not found!"
    return
  endtry

  let tag_cmd = len(split(tselect_out, '\n')) > 5 ? 'tselect' : 'tag'
  DirectionalSplit
  if !empty(g:last_direction_split)
    exec join([tag_cmd, a:tag])
  endif
endfunction
command! -nargs=1 Dtag call s:directional_tag(<f-args>)
nnoremap ts :exec 'Dtag '.expand('<cword>')<CR>
vnoremap <silent> ts :<C-U>exec 'Dtag '.<SID>get_visual_selection()<CR>

if has('nvim')
  " directional term splits
  command! -nargs=? Dterm DirectionalSplit term://$SHELL <args> | startinsert
  cnoreabbrev dterm Dterm
  cnoreabbrev dt Dterm
  nnoremap <leader>d :Dterm<CR>

  function! s:localdterm(...) abort
    let localdir = expand('%:p:h')
    let dirsplit_cmd = join(extend(['DirectionalSplit', 'NONE'], a:000))
    exec dirsplit_cmd." | lcd ".localdir." | term"
  endfunction

  command! -nargs=? LDterm call <sid>localdterm(<f-args>)
  cnoreabbrev ldterm LDterm
  cnoreabbrev d. LDterm
  cnoreabbrev d, LDterm

  " terminal mappings
  tnoremap <C-w>h <C-\><C-n><C-w>h
  tnoremap <C-w>j <C-\><C-n><C-w>j
  tnoremap <C-w>k <C-\><C-n><C-w>k
  tnoremap <C-w>l <C-\><C-n><C-w>l

  augroup term_autocmds
    autocmd!

    " escape terminal mappings
    autocmd TermOpen * tnoremap <buffer> <Esc><Esc> <C-\><C-n>
    autocmd FileType fzf tunmap <buffer> <Esc><Esc>

    " focus terminal automatically
    exec 'autocmd BufEnter term://$SHELL startinsert'
  augroup END
endif

command! ProfileStart profile start ~/temp/profile.log | profile func * | profile file *
command! ProfileDone profile pause | noautocmd qall!

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" tComment {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Use <leader>c to comment lines of code
nmap <leader>c :TComment<CR>
vmap <leader>c :TComment<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Lightline {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set laststatus=2   " Always show the statusline
let g:lightline = {
      \   'colorscheme': 'Tomorrow_Night',
      \   'active': {
      \     'left': [['zoom', 'mode', 'paste'], ['fileinfo', 'syntax_err', 'syntax_war']],
      \     'right': [['lineinfo'], ['fugitive'], ['filetype', 'winnr']]
      \   },
      \   'inactive': {
      \     'left': [['fileinfo']],
      \     'right': [['lineinfo'], ['fugitive'], ['filetype', 'winnr']]
      \   },
      \   'component': {
      \     'winnr': '%{winnr()}',
      \     'fugitive': '%{exists("*fugitive#head")?fugitive#head(5):""}',
      \   },
      \   'component_function' : {
      \     'zoom': 'LLZoom',
      \     'mode': 'LLMode',
      \     'fileinfo': 'LLFileInfo',
      \     'lineinfo': 'LLLineInfo',
      \     'filetype': 'LLFileType',
      \   },
      \   'component_expand' : {
      \     'gitsync': 'Gitsync',
      \     'syntax_err': 'SyntaxError',
      \     'syntax_war': 'SyntaxWarning',
      \   },
      \   'component_type': {
      \     'gitsync': 'error',
      \     'syntax_err': 'error',
      \     'syntax_war': 'warning',
      \   },
      \ }

function! Gitsync()
  if !get(g:, 'gitsync_initialized', 0) | return '' | endif
  return GitsyncStatus(bufnr('%'))
endfunction

function! SyntaxError()
  if !exists('*neomake#statusline#LoclistCounts') | return '' | endif
  let counts = neomake#statusline#LoclistCounts()
  if !has_key(counts, 'E') | return '' | endif
  return printf('%s %d', s:E, counts['E'])
endfunction
function! SyntaxWarning()
  if !exists('*neomake#statusline#LoclistCounts') | return '' | endif
  let counts = neomake#statusline#LoclistCounts()
  if !has_key(counts, 'W') | return '' | endif
  return printf('%s %d', s:W, counts['W'])
endfunction

" mode
function! LLMode()
  let mode = get({
        \ 'nerdtree': 'nerdtree',
        \ 'fzf': 'FZF',
        \ }, &ft)
  if empty(mode)
    let mode = lightline#mode()
  endif
  return mode
endfunction

" zoom
function! LLZoom()
  return (exists('t:zoomed') && t:zoomed) ? 'ZOOM' : ''
endfunction

" filename and fileinfo
let g:pathname_depth = 3
function! LLModified()
  return index(['help', 'nerdtree'], &ft) > -1 ? '' :
        \ &modified ? '+' : ''
endfunction
function! LLReadonly()
  return index(['help', 'nerdtree'], &ft) < 0 && &readonly ? '🔒' : ''
endfunction
function! LLTrucatedFilePath()
  if (&ft =~ 'nerdtree' || &buftype ==# 'terminal') | return '' | endif
  let bufnr = bufnr('%')
  let buf_trunc_path = getbufvar(bufnr, 'trunc_path')
  if empty(buf_trunc_path)
    let fullpath = expand('%:p:~')
    let buf_trunc_path = empty(fullpath) ? '[No Name]' :
          \ matchstr(fullpath,
          \   printf('\(\~\)\?\(/[0-9a-zA-Z_~\-. ]\+\)\{,%d}/[0-9a-zA-Z_\-. ]\+$',
          \   get(g:, 'pathname_depth', 3)))
    call setbufvar(bufnr, 'trunc_path', buf_trunc_path)
  endif
  return buf_trunc_path
endfunction
autocmd BufNewFile * unlet b:trunc_path
function! LLFileInfo()
  if index(['nerdtree', 'fzf'], &ft) > -1 | return '' | endif
  let segments = [LLReadonly(), LLTrucatedFilePath(), LLModified()]
  return substitute(join(segments, ' '), '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction
function! LLLineInfo()
  if index(['nerdtree', 'fzf'], &ft) > -1 | return '' | endif
  let [_, l, c, _] = getpos('.')
  return l.':'.c
endfunction
function! LLLineInfo()
  if index(['nerdtree', 'fzf'], &ft) > -1 | return '' | endif
  return &ft
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-easyalign {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. <leader>aip)
nmap <leader>a <Plug>(EasyAlign)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" a.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" toggle between .h and .c with <leader>a
nnoremap <leader>a :A<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" deoplete {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if s:plug_loaded('deoplete.nvim')
  let g:deoplete#enable_at_startup = 1

  imap <silent><expr> <Tab> pumvisible() ? "\<C-n>" : "<Tab>"
  imap <silent><expr> <S-Tab> pumvisible() ? "\<C-p>" : "<S-Tab>"
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" neosnippet {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if s:plug_loaded('neosnippet.vim')
  let g:neosnippet#snippets_directory = $HOME.'/.vim/snippets'
  let g:neosnippet#disable_runtime_snippets = {
        \ '_': 1,
        \ } " disable built-in snippets

  " expand snippets with Enter
  imap <silent><expr> <CR> neosnippet#expandable_or_jumpable() ?
        \ "\<Plug>(neosnippet_expand_or_jump)" : "\<CR>"
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Neomake {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if s:plug_loaded('neomake')
  let g:neomake_verbose = 0 " useful for debug

  exec "highlight! NeomakeError ctermfg=red guifg=".GetHiKey('Error', 'guifg')
  exec "highlight! NeomakeWarning ctermfg=yellow guifg=".GetHiKey('Todo', 'guifg')

  let g:neomake_error_sign = {
        \ 'text': s:E,
        \ 'texthl': 'NeomakeError',
        \ }
  let g:neomake_warning_sign = {
        \ 'text': s:W,
        \ 'texthl': 'NeomakeWarning',
        \ }

  if executable('pylama')
    let g:neomake_python_enabled_makers = ['pylama']
  endif
  let g:neomake_tex_enabled_makers = []

  function! ToggleLocationList()
    if empty(filter(tabpagebuflist(), 'getbufvar(v:val, "&buftype") is# "quickfix"'))
      lwindow
    else
      lclose
    endif
  endfunction
  nnoremap <silent> <leader>1 :call ToggleLocationList()<CR>

  command! -nargs=0 DisableNeomake let b:neomake_enabled=0

  function! NeomakeLightlineCallback(callback_dict)
    if !a:callback_dict['has_next'] | call lightline#update() | endif
  endfunction

  augroup postwrite_neomake
    autocmd!
    autocmd BufWinEnter,BufWritePost *
          \ if !get(b:, 'goyo_enabled', 0) && get(b:, 'neomake_enabled', 1) |
          \ call neomake#Make(1, [], function("NeomakeLightlineCallback")) |
          \ endif
  augroup END

  let g:neomake_place_signs_at_once = 1
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" fzf {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if s:plug_loaded('fzf')
  cnoreabbrev fzf FZF
  cnoreabbrev f FZF

  let g:fzf_action = {
        \ 'ctrl-t': 'tab split | drop',
        \ 'ctrl-x': 'split | drop',
        \ 'ctrl-v': 'vsplit | drop',
        \ 'ctrl-s': 'DirectionalSplit',
        \ 'enter': 'DirectionalSplit' }

  function! s:git_fzf(...)
    let from_dir = a:0 ? a:1 : '.'
    let gitroot = s:gitroot(from_dir)
    if empty(gitroot)
      exec 'FZF --header="Searching from: '.from_dir.'" '.from_dir
    else
      exec 'FZF -d '.gitroot.' --with-nth=2 --header="Git Repo: '.gitroot.'" '.gitroot
    endif
  endfunction

  nnoremap <silent> <leader>j :call <SID>git_fzf()<CR>
  nnoremap <silent> <leader>o :echo 'Use j instead bruh'<CR>
  nnoremap <silent> <leader>. :call <SID>git_fzf(expand('%:p:h'))<CR>
end

if s:plug_loaded('fzf.vim')
  nnoremap <silent> <leader>t :Tags<CR>
  nnoremap <silent> <leader>gf :GFiles?<CR>

  if has('nvim')
    function! s:fzf_statusline()
      " do nothing, default statusbar pls
    endfunction
    autocmd! User FzfStatusLine call s:fzf_statusline()
  end
end


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-grepper {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:grepper = {
      \ 'tools': ['ag', 'git', 'grep'],
      \ 'open': 1,
      \ 'jump': 0,
      \ }

let g:grepper.ag =
      \ { 'grepprg': 'ag --vimgrep $* `git rev-parse --show-toplevel`' }

command! -nargs=* Ag Grepper -noprompt -tool ag -query <args>
cnoreabbrev ag Ag

nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" vim-easymotion {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" enable easymotion with one leaderkey press
map <leader> <Plug>(easymotion-prefix)

" blue and green ayyy lmao
exec 'hi! EasyMotionTarget ctermfg=39 guifg='.RGBtoHex(26, 155, 252)
exec 'hi! EasyMotionTarget2First ctermfg=40 guifg='.RGBtoHex(31, 202, 35)
exec 'hi! EasyMotionTarget2Second ctermfg=28 guifg='.RGBtoHex(10, 101, 12)

" vim-easyoperator-line
let s:EasyOperator_line_do_mapping = 0
let s:EasyOperator_line_first = 'CursorLine'
omap <silent>  <leader>l <Plug>(easyoperator-line-select)
xmap <silent>  <leader>l <Plug>(easyoperator-line-select)
nmap <silent> d<leader>l <Plug>(easyoperator-line-delete)
nmap <silent> y<leader>l <Plug>(easyoperator-line-yank)

" vim-easymotion-segments
let g:EasyMotionSegments_key = 's'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Text Objects {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-textobj-user.vim
augroup TextobjUserSetup
  autocmd!
  autocmd BufEnter * call TextobjUserSetup()
augroup END

function! TextobjUserSetup()
  if s:plug_loaded('vim-textobj-user')
    " textobj for current line
    " Copied from: https://github.com/kana/vim-textobj-user
    call textobj#user#plugin('line', {
          \   '-': {
          \     'select-a': 'al', 'select-a-function': 'TextobjCurrentLineA',
          \     'select-i': 'il', 'select-i-function': 'TextobjCurrentLineI',
          \   },
          \ })

    function! TextobjCurrentLineA()
      normal! 0
      let head_pos = getpos('.')
      normal! $
      let tail_pos = getpos('.')
      return ['v', head_pos, tail_pos]
    endfunction

    function! TextobjCurrentLineI()
      normal! ^
      let head_pos = getpos('.')
      normal! g_
      let tail_pos = getpos('.')
      let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
      return
            \ non_blank_char_exists_p
            \ ? ['v', head_pos, tail_pos]
            \ : 0
    endfunction

    " textobj to turn foo_bar_baz into foo_baz *and* quuxSpamEggs into quuxEggs
    " Copied from: https://github.com/Julian/vim-textobj-variable-segment/blob/master/plugin/textobj/variable-segment.vim
    call textobj#user#plugin('variable', {
          \ '-': {
          \     'select-a': 'as',  'select-a-function': 'TextobjSelectSegmentA',
          \     'select-i': 'is',  'select-i-function': 'TextobjSelectSegmentI',
          \ }})

    function! TextobjSelectSegment(object_type, right_boundary)
      let left_boundaries = ['_\+\i', '\<', '\l\u', '\u\u\ze\l', '\a\d', '\d\a', '#\a']
      call search(join(left_boundaries, '\|'), 'bce')
      let start_position = getpos('.')

      call search('\>', 'c')
      let word_end = getpos('.')
      call setpos('.', start_position)

      call search(a:right_boundary, 'c')
      for _ in range(v:count1 - 1)
        if getpos('.') != word_end
          call search(a:right_boundary)
        endif
      endfor
      let end_position = getpos('.')

      return ['v', start_position, end_position]
    endfunction

    function! TextobjSelectSegmentA()
      let right_boundaries = ['_', '\l\u', '\u\u\l', '\a\d', '\d\a', '\i\>', '\a#']
      let right_boundary = join(right_boundaries, '\|')
      let [type, start_position, end_position] = TextobjSelectSegment('a', right_boundary)
      let [_, start_line, start_column, _] = start_position

      call search('\i\>', 'c')
      if end_position == getpos('.') &&
            \ getline(start_line)[start_column - 2] =~# '_'
        let start_position[2] -= 1
      endif

      let was_small_camel = match(expand('<cword>'), '^_*\l.*\u') != -1
      if was_small_camel
        call search('\<', 'bc')
        let [_, _, word_start, _] = getpos('.')

        if start_column - 2 <= word_start ||
              \ getline(start_line)[:start_column - 2] =~# '^_*$'
          call setpos('.', end_position)
          normal! l~
        endif
      endif

      return [type, start_position, end_position]
    endfunction

    function! TextobjSelectSegmentI()
      let right_boundaries = ['\i_', '\l\u', '\u\u\l', '\a\d', '\d\a', '\i\>', '\a#']
      return TextobjSelectSegment('i', join(right_boundaries, '\|'))
    endfunction

    " select entire file
    " Source: https://github.com/kana/vim-textobj-entire
    call textobj#user#plugin('entire', {
          \      '-': {
          \        '*sfile*': expand('<sfile>:p'),
          \        'select-a': 'ae',  '*select-a-function*': 'TextobjSelectEntireA',
          \        'select-i': 'ie',  '*select-i-function*': 'TextobjSelectEntireI'
          \      }
          \    })

    function! TextobjSelectEntireA()
      " To easily back to the last position after a command.
      " For example: yae<C-o>
      mark '

      keepjumps normal! gg0
      let start_pos = getpos('.')

      keepjumps normal! G$
      let end_pos = getpos('.')

      return ['V', start_pos, end_pos]
    endfunction

    function! TextobjSelectEntireI()
      " To easily back to the last position after a command.
      " For example: yie<C-o>
      mark '

      keepjumps normal! gg0
      call search('^.', 'cW')
      let start_pos = getpos('.')

      keepjumps normal! G$
      call search('^.', 'bcW')
      normal! $
      let end_pos = getpos('.')

      return ['V', start_pos, end_pos]
    endfunction

  endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" incsearch.vim {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set hlsearch
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)

" stay on *
map <silent> g* :let @/='\<'.expand('<cword>').'\>'<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Goyo {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! s:goyo_enter()
  set noshowmode
  set noshowcmd
  let b:goyo_enabled = 1
  let b:quitting = 0
  let b:quitting_bang = 0
  augroup goyo_quitpre
    autocmd!
    autocmd QuitPre <buffer> let b:quitting = 1
  augroup END
  cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
endfunction

function! s:goyo_leave()
  set showmode
  set showcmd
  let b:goyo_enabled = 0
  " Quit Vim if this is the only remaining buffer
  if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
    if b:quitting_bang
      qa!
    else
      qa
    endif
  endif
  autocmd! goyo_quitpre
endfunction

augroup goyo
  autocmd!
  autocmd User GoyoEnter nested call <SID>goyo_enter()
  autocmd User GoyoLeave nested call <SID>goyo_leave()
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" NERDTree {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let NERDTree hijack netrw while still having async load
let g:NERDTreeHijackNetrw = 1
function! s:plugasync_nerdtree_checkForBrowse(dir)
  silent! autocmd! FileExplorer
  if a:dir != '' && isdirectory(a:dir)
    if !exists('#NERDTree') | call plug#load('nerdtree') | endif
    call nerdtree#checkForBrowse(dir)
  endif
endfunction
augroup async_nerdtree
  autocmd!
  autocmd VimEnter * call s:plugasync_nerdtree_checkForBrowse(expand("<amatch>"))
augroup END

nnoremap <silent> <leader>k :NERDTreeFind<CR>
nnoremap <silent> <leader>l :NERDTreeToggle<CR>

let g:NERDTreeWinSize = 35
let g:NERDTreeQuitOnOpen = 1

" close Vim if NERDTree is the only window left
augroup nerdtree_solo_close
  autocmd!
  autocmd BufEnter *
        \ if (winnr("$")==1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) |
        \ q |
        \ endif
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Filetype {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" line wrap sucks for some files, but it's nice to choose the wrap width
function! s:manual_format(type, ...)
  let og_width = &textwidth
  let manual_width = get(b:, 'tw', -1)
  if manual_width == -1 | let manual_width = get(g:, 'tw', &textwidth) | endif
  exec 'set textwidth='.manual_width

  if a:0  " Invoked from Visual mode
    silent exe "normal! '<v'>gq"
  elseif a:type == 'line'
    silent exe "normal! '[V']gq"
  elseif a:type == 'block'
    silent exe "normal! '[\<C-V>']gq"
  else
    silent exe "normal! '[v']gq"
  endif

  exec 'set textwidth='.og_width
endfunction!

function! s:git_commit_ft()
  set textwidth=72
  set colorcolumn=71,72
  call matchaddpos('ColorColumn', [[1, 49, 2]])
endfunction

augroup vimrc_filetype
  autocmd!
  autocmd BufNewFile,BufReadPost *.md set filetype=markdown
  autocmd BufNewFile,BufReadPost Vagrantfile set filetype=ruby
  autocmd FileType c,cpp,vim,javascript,coffee,html,jinja setl sw=2 ts=2 sts=2 et
  autocmd BufNewFile,BufReadPost PULLREQ_EDITMSG set filetype=markdown.ghpull
  autocmd BufNewFile,BufReadPost COMMIT_EDITMSG call s:git_commit_ft()
  autocmd Filetype tex,markdown,noft,text
        \ set wrap |
        \ set breakindent |
        \ set linebreak |
        \ set textwidth=9999 |
        \ exec 'nnoremap <silent> $ g$' |
        \ exec 'nnoremap <silent> ^ g^' |
        \ let b:tw = 119 |
        \ exec 'nnoremap <silent> gq :set opfunc=<SID>manual_format<CR>g@' |
        \ exec 'vnoremap <silent> gq :<C-U>call <SID>manual_format(visualmode(), 1)<CR>'
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Fugitive {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if get(g:, 'colors_name', 'NONE') == 'hybrid_ayk'
  hi! DiffAdd    guifg=NONE guibg=#1d2821
  hi! DiffChange guifg=NONE guibg=#1d1f34
  exec "hi! DiffDelete guifg=".GetHiKey('Normal', 'guibg')." guibg=#381f21"
  exec "hi! DiffText   guifg=".GetHiKey('Normal', 'guifg')." guibg=#1d1f60"
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" git commit through nvr {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! s:nvr_git_commit(commit_msg)
  exec 'split '.a:commit_msg |
        \ autocmd BufDelete,BufHidden,BufUnload <buffer>
        \ call system('touch '.expand('%:p:h').'/.nvr_finished_commit') |
        \ bwipeout |
        \ autocmd!
endfunction
command! -nargs=1 NvrGitCommit call <SID>nvr_git_commit(<f-args>)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
" Stripe {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! s:run_payserver_test(...)
  let gitroot = system('git rev-parse --show-toplevel')
  let gitroot = substitute(gitroot, '\n\+$', '', 'g').'/' " strip whitespace

  let line_number = a:1 ? '' : ':'.line('.')
  let test_file = expand('%:p').line_number

  belowright new | call termopen([gitroot.'scripts/bin/test', test_file])
endfunction
command! -bang PSTest call s:run_payserver_test(<bang>0)


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
